

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Driver for the USB-CTR08 &mdash; EPICS support for Measurement Computing devices</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/my_theme.css?v=254ed751" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Driver for Multi-Function Devices" href="measCompMultiFunctionDoc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            measComp
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="measCompMultiFunctionDoc.html">Driver for Multi-Function Devices</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Driver for the USB-CTR08</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#databases">Databases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#digital-i-o-functions">Digital I/O Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pulse-generator-functions">Pulse Generator Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scaler-record-support">Scaler Record Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-channel-scaler-mcs-support">Multi-Channel Scaler (MCS) Support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#notes-on-external-channel-advance">Notes on external channel advance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-an-external-gate-signal">Using an external gate signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#packaging">Packaging</a></li>
<li class="toctree-l2"><a class="reference internal" href="#medm-screens">medm screens</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-measurements">Performance measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#restrictions">Restrictions</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">measComp</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Driver for the USB-CTR08</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/measCompUSBCTRDoc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="driver-for-the-usb-ctr08">
<h1><a class="toc-backref" href="#id12" role="doc-backlink">Driver for the USB-CTR08</a><a class="headerlink" href="#driver-for-the-usb-ctr08" title="Link to this heading"></a></h1>
<dl class="field-list simple">
<dt class="field-odd">author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mark Rivers, University of Chicago</p>
</dd>
</dl>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#driver-for-the-usb-ctr08" id="id12">Driver for the USB-CTR08</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction" id="id13">Introduction</a></p></li>
<li><p><a class="reference internal" href="#configuration" id="id14">Configuration</a></p></li>
<li><p><a class="reference internal" href="#databases" id="id15">Databases</a></p>
<ul>
<li><p><a class="reference internal" href="#digital-i-o-functions" id="id16">Digital I/O Functions</a></p></li>
<li><p><a class="reference internal" href="#pulse-generator-functions" id="id17">Pulse Generator Functions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#scaler-record-support" id="id18">Scaler Record Support</a></p></li>
<li><p><a class="reference internal" href="#multi-channel-scaler-mcs-support" id="id19">Multi-Channel Scaler (MCS) Support</a></p>
<ul>
<li><p><a class="reference internal" href="#notes-on-external-channel-advance" id="id20">Notes on external channel advance</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-an-external-gate-signal" id="id21">Using an external gate signal</a></p></li>
<li><p><a class="reference internal" href="#packaging" id="id22">Packaging</a></p></li>
<li><p><a class="reference internal" href="#medm-screens" id="id23">medm screens</a></p></li>
<li><p><a class="reference internal" href="#performance-measurements" id="id24">Performance measurements</a></p></li>
<li><p><a class="reference internal" href="#restrictions" id="id25">Restrictions</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<span id="id1"></span><h2><a class="toc-backref" href="#id13" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>This is an <a class="reference external" href="https://epics-controls.org/">EPICS</a> driver for the
<a class="reference external" href="http://www.mccdaq.com/usb-data-acquisition/USB-CTR08.aspx">USB-CTR04 and USB-CTR08</a>
counter/timer modules from <a class="reference external" href="https://www.mccdaq.com">MeasurementComputing</a>.</p>
<p>The driver is written in C++, and consists of a class that inherits from
<a class="reference external" href="https://epics-modules.github.io/master/asyn/R4-41/asynPortDriver.html">asynPortDriver</a>, which is part of the EPICS <a class="reference external" href="https://github.com/epics-modules/asyn">asyn</a> module.</p>
<figure class="align-center" id="id5">
<img alt="_images/USB-CTR08.jpg" src="_images/USB-CTR08.jpg" />
<figcaption>
<p><span class="caption-text"><strong>Photo of USB-CTR08</strong></span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This module has the following features:</p>
<ul class="simple">
<li><p>Digital inputs/outputs</p>
<ul>
<li><p>8 signals, individually programmable as inputs or outputs</p></li>
</ul>
</li>
<li><p>Pulse generators. 4 pulse generators each with</p>
<ul>
<li><p>48MHz clock, 32-bit registers</p></li>
<li><p>Programmable period, width, number of pulses, polarity</p></li>
</ul>
</li>
<li><p>Counters. 8 counters (USB-CTR08) or 4 counters (USB-CTR04)</p>
<ul>
<li><p>48 MHz maximum count rate</p></li>
<li><p>Support for EPICS scaler record (similar to Joerger VSC and
SIS3820)</p></li>
<li><p>Support for Multi-Channel Scaler (MCS) mode, similar to SIS3820.</p></li>
</ul>
</li>
</ul>
</section>
<section id="configuration">
<span id="id2"></span><h2><a class="toc-backref" href="#id14" role="doc-backlink">Configuration</a><a class="headerlink" href="#configuration" title="Link to this heading"></a></h2>
<p>The following lines are needed in the EPICS startup script for the
USBCTR.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># This line is for Linux only
cbAddBoard(&quot;USB-CTR&quot;, &quot;&quot;)

## Set the minimum sleep time to 1 ms
asynSetMinTimerPeriod(0.001)

## Configure port driver
# USBCTRConfig(portName,       # The name to give to this asyn port driver
#              boardNum,       # The number of this board assigned by the Measurement Computing Instacal program
#              maxTimePoints)  # Maximum number of time points for MCS
USBCTRConfig(&quot;$(PORT)&quot;, 0, 2048, .01)

#asynSetTraceMask($(PORT), 0, TRACE_ERROR|TRACE_FLOW|TRACEIO_DRIVER)

dbLoadTemplate(&quot;USBCTR.substitutions&quot;)

# This loads the scaler record and supporting records
dbLoadRecords(&quot;$(SCALER)/db/scaler.db&quot;, &quot;P=USBCTR:, S=scaler1, DTYP=Asyn Scaler, OUT=@asyn(USBCTR), FREQ=10000000&quot;)

# This database provides the support for the MCS functions
dbLoadRecords(&quot;$(MEASCOMP)/measCompApp/Db/measCompMCS.template&quot;, &quot;P=$(PREFIX), PORT=$(PORT)&quot;)

# Load either MCA or waveform records below
# The number of records loaded must be the same as MAX_COUNTERS defined above

# Load the MCA records
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)1,  DTYP=asynMCA, INP=@asyn($(PORT) 0),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)2,  DTYP=asynMCA, INP=@asyn($(PORT) 1),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)3,  DTYP=asynMCA, INP=@asyn($(PORT) 2),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)4,  DTYP=asynMCA, INP=@asyn($(PORT) 3),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)5,  DTYP=asynMCA, INP=@asyn($(PORT) 4),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)6,  DTYP=asynMCA, INP=@asyn($(PORT) 5),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)7,  DTYP=asynMCA, INP=@asyn($(PORT) 6),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)8,  DTYP=asynMCA, INP=@asyn($(PORT) 7),  PREC=3, CHANS=$(MAX_POINTS)&quot;)
#dbLoadRecords(&quot;$(MCA)/mcaApp/Db/simple_mca.db&quot;, &quot;P=$(PREFIX), M=$(RNAME)9,  DTYP=asynMCA, INP=@asyn($(PORT) 8),  PREC=3, CHANS=$(MAX_POINTS)&quot;)

# This loads the waveform records
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)1,  INP=@asyn($(PORT) 0),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)2,  INP=@asyn($(PORT) 1),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)3,  INP=@asyn($(PORT) 2),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)4,  INP=@asyn($(PORT) 3),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)5,  INP=@asyn($(PORT) 4),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)6,  INP=@asyn($(PORT) 5),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)7,  INP=@asyn($(PORT) 6),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)8,  INP=@asyn($(PORT) 7),  CHANS=$(MAX_POINTS)&quot;)
dbLoadRecords(&quot;$(MCA)/mcaApp/Db/SIS38XX_waveform.template&quot;, &quot;P=$(PREFIX), R=$(RNAME)9,  INP=@asyn($(PORT) 8),  CHANS=$(MAX_POINTS)&quot;)

asynSetTraceIOMask($(PORT),0,2)
#asynSetTraceFile(&quot;$(PORT)&quot;,0,&quot;$(MODEL).out&quot;)

&lt; save_restore.cmd
save_restoreSet_status_prefix($(PREFIX))
dbLoadRecords(&quot;$(AUTOSAVE)/asApp/Db/save_restoreStatus.db&quot;, &quot;P=$(PREFIX)&quot;)

iocInit

seq(USBCTR_SNL, &quot;P=$(PREFIX), R=$(RNAME), NUM_COUNTERS=$(MAX_COUNTERS), FIELD=$(FIELD)&quot;)
create_monitor_set(&quot;auto_settings.req&quot;,30)
</pre></div>
</div>
<p>The measComp module comes with an example iocBoot/iocUSBCTR directory
that contains and example startup script and example substitution files.</p>
</section>
<section id="databases">
<span id="id3"></span><h2><a class="toc-backref" href="#id15" role="doc-backlink">Databases</a><a class="headerlink" href="#databases" title="Link to this heading"></a></h2>
<p>The following tables list the database template files that are used with
the USB-CTR04/08.</p>
<section id="digital-i-o-functions">
<span id="digitalio"></span><h3><a class="toc-backref" href="#id16" role="doc-backlink">Digital I/O Functions</a><a class="headerlink" href="#digital-i-o-functions" title="Link to this heading"></a></h3>
<p>These are the records defined in the following files:</p>
<ul class="simple">
<li><p>measCompBinaryIn.template. This database is loaded once for each binary I/O bit.</p></li>
<li><p>measCompLongIn.template. This database is loaded once for each binary I/O register.</p></li>
<li><p>measCompBinaryOut.template. This database is loaded once for each binary I/O bit.</p></li>
<li><p>measCompLongOut.template. This database is loaded once for each binary I/O register.</p></li>
<li><p>measCompBinaryDir.template. This database is loaded once for each binary I/O bit.</p></li>
</ul>
<table class="table-bordered table-striped table-hover docutils align-default">
<colgroup>
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 60.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>EPICS record name</p></th>
<th class="head"><p>EPICS record type</p></th>
<th class="head"><p>asyn interface</p></th>
<th class="head"><p>drvInfo string</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>$(P)$(R)</p></td>
<td><p>bi</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_INPUT</p></td>
<td><p>Digital input value. The MASK parameter in the INP link defines which bit is used.
The binary inputs are polled by the driver poller thread, so these records should
have SCAN=”I/O Intr”.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)</p></td>
<td><p>longin</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_INPUT</p></td>
<td><p>Digital input value as a word, rather than individual bits. The MASK parameter in
the INP link defines which bits are used. The binary inputs are polled by the driver
poller thread, so this record should have SCAN=”I/O Intr”.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)</p></td>
<td><p>bo</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_OUTPUT</p></td>
<td><p>Digital output value. The MASK parameter in the INP link defines which bit is used.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)_RBV</p></td>
<td><p>bi</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_OUTPUT</p></td>
<td><p>Digital output value readback. The MASK parameter in the INP link defines which
bit is used.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)</p></td>
<td><p>longout</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_OUTPUT</p></td>
<td><p>Digital output value as a word, rather than individual bits. The MASK parameter
in the INP link defines which bits are used.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)_RBV</p></td>
<td><p>longin</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_OUTPUT</p></td>
<td><p>Digital output value readback as a word, rather than individual bits. The MASK parameter
in the INP link defines which bits are used.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)</p></td>
<td><p>bo</p></td>
<td><p>asynUInt32Digital</p></td>
<td><p>DIGITAL_DIRECTION</p></td>
<td><p>Direction of this I/O line, “In” (0) or “Out” (1). The MASK parameter in the INP
link defines which bit is used.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pulse-generator-functions">
<span id="pulsegen"></span><h3><a class="toc-backref" href="#id17" role="doc-backlink">Pulse Generator Functions</a><a class="headerlink" href="#pulse-generator-functions" title="Link to this heading"></a></h3>
<p><strong>Note:</strong> These are called “timers” in Measurement Computing’s documentation.</p>
<p>These are the records defined in measCompPulseGen.template.
This database is loaded once for each pulse generator.</p>
<table class="table-bordered table-striped table-hover docutils align-default">
<colgroup>
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 60.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>EPICS record name</p></th>
<th class="head"><p>EPICS record type</p></th>
<th class="head"><p>asyn interface</p></th>
<th class="head"><p>drvInfo string</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>$(P)$(R)Run</p></td>
<td><p>bo</p></td>
<td><p>asynUInt32</p></td>
<td><p>PULSE_RUN</p></td>
<td><p>“Run” (1) starts the pulse generator, “Stop” (0) stops the pulse generator. Note
that ideally this record should go back to 0 when the pulse generator is done, if
it is outputting a finite number of pulses (see Count record). But unfortunately
the Measurement Computing library does not have a way to query the status of the
timer to see if it is done, so this is not possible.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Period</p></td>
<td><p>ao</p></td>
<td><p>asynFloat64</p></td>
<td><p>PULSE_PERIOD</p></td>
<td><p>Pulse period, in seconds. The time between pulses can be defined either with the
Period or with the Frequency; whenever one record is changed the other is updated
with the new calculated value.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)Frequency</p></td>
<td><p>ao</p></td>
<td><p>N.A.</p></td>
<td><p>N.A.</p></td>
<td><p>Pulse frequency, in seconds. The Frequency calculates a new value of the Period,
and sends the period value to the driver.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Width</p></td>
<td><p>ao</p></td>
<td><p>asynFloat64</p></td>
<td><p>PULSE_WIDTH</p></td>
<td><p>Pulse width, in seconds. The allowed range is 15.625 ns to (Period-15.625 ns).</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)Delay</p></td>
<td><p>ao</p></td>
<td><p>asynFloat64</p></td>
<td><p>PULSE_DELAY</p></td>
<td><p>Initial pulse delay in seconds after Run is set to 1.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Count</p></td>
<td><p>longout</p></td>
<td><p>asynInt32</p></td>
<td><p>PULSE_COUNT</p></td>
<td><p>Number of pulses to output. If the Count is 0 then the pulse generator runs continuously
until Run is set to 0.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)IdleState</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>PULSE_IDLE_STATE</p></td>
<td><p>The idle state of the pulse output line, “Low” (0) or “High” (1). This determines
the polarity of the pulse, i.e. positive going or negative going.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="scaler-record-support">
<span id="scalersupport"></span><h2><a class="toc-backref" href="#id18" role="doc-backlink">Scaler Record Support</a><a class="headerlink" href="#scaler-record-support" title="Link to this heading"></a></h2>
<p>The USBCTR driver supports the EPICS scaler record via the
devScalerAsyn.c device support originally from the
<a class="reference external" href="http://www.aps.anl.gov/bcda/synApps">synApps</a>
<a class="reference external" href="http://www.aps.anl.gov/bcda/synApps/std/std.html">std</a> module but
which has been moved into the
<a class="reference external" href="https://github.com/epics-modules/scaler">scaler</a> module. It supports
up to 8 channels. The following wiring connections must be made in order
for counters 1-8 to be stopped by counter 0, as is normally desired.</p>
<ul class="simple">
<li><p>Counter 0 Output must be connected to the Gate input on Counters 1-7.</p></li>
</ul>
<p>The .PR1 preset is performed in hardware via the Counter 0 Output and
Counters 1-7 gates. Counters 1-7 can also be set as preset counters, and
the scaler record will stop counting when any of these preset values
(.PR2-.PR8) are exceeded. However, unlike the .PR1 preset, these presets
are done in software in the driver polling routine. The device sends
readings at 100 Hz, and whenever a preset is exceeded counting is
stopped. Each of the counters will have counted for exactly the same
amount of time, but the actual count time could be up to 0.01 seconds
longer than the time when the preset was reached.</p>
<p>Counter 0 is normally used as the preset counter, and is connected to a
fixed frequency source. Any of the on-board pulse generators can be used
to provide this frequency source, for example. It is important to set
the scaler record .FREQ field to be the value of the Frequency_RBV of
the pulse generator (the actual frequency) and not the Frequency field
(the requested frequency) since these can differ, particularly at
frequencies &gt;1 MHz.</p>
</section>
<section id="multi-channel-scaler-mcs-support">
<span id="mcssupport"></span><h2><a class="toc-backref" href="#id19" role="doc-backlink">Multi-Channel Scaler (MCS) Support</a><a class="headerlink" href="#multi-channel-scaler-mcs-support" title="Link to this heading"></a></h2>
<p>The USBCTR driver provides multi-channel scaler support very similar to
the SIS3820 driver in the synApps mca module. The support has the
following properties:</p>
<ul class="simple">
<li><p>The number of counters being used in MCS mode can be selected with
the FirstCounter and LastCounter records. Each can range from 0 to 7;
LastCounter must be greater than or equal to FirstCounter. The number
of active counters can thus range from 1 to 8.</p></li>
<li><p>The minimum dwell time, either with internal or external channel
advance, is 250 ns times the number of active counters. For example
if only 2 counters are being used, the clock input on Counter 0 and a
signal on Counter 1, then the minimum dwell time is 500 ns. If all 8
counters are being used then the minimum dwell time is 2
microseconds.</p></li>
<li><p>Either MCS or waveform records can be used to hold the time series
data.</p></li>
<li><p>There is no limitation on the length of the waveform or mca records,
only the size of system RAM.</p></li>
<li><p>An external channel advance signal can be used directly by connecting
it to the External Clock Input (CLKI)on the USB-CTR module. The
minimum dwell time (period) of this signal is described above.</p></li>
<li><p>An external channel advance can be “prescaled” (frequency divided by
N) by connecting it to a counter input. This counter is assigned to
the PrescaleCounter record. The Counter Output of the PrescaleCounter
must be connected to the External Clock Input on the USB-CTR module.
I have asked Measurment Computing to consider adding a prescale
register for the CLKI signal in a future firmware version, but I
don’t know if this will be done.</p></li>
<li><p>To achieve the shortest dwell times the counter must be read in
16-bit mode rather than 32-bit mode. This is handled automatically by
the driver. If the dwell time is less than 100 microseconds the
counters are read in 16-bit mode, while for longer dwell times they
are read in 32-bit mode. There is no possible loss of data when
reading in 16-bit mode because at the maximum count rate of 48 MHz
only 4800 counts can occur in 100 microseconds, which is much less
than the 16-bit limit. NOTE: When using external channel advance the
Dwell record should be set to the approximate time between external
pulses. This will cause the correct 32-bit/16-bit switch to occur so
that the minimum dwell time can be reached and so the counters don’t
overflow 16-bits for longer dwell times.</p></li>
</ul>
<p>The following record are defined in measCompMCS.template. This database is loaded once per module.</p>
<table class="table-bordered table-striped table-hover docutils align-default">
<colgroup>
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 60.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>EPICS record name</p></th>
<th class="head"><p>EPICS record type</p></th>
<th class="head"><p>asyn interface</p></th>
<th class="head"><p>drvInfo string</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>$(P)$(R)SNL_Connected</p></td>
<td><p>bi</p></td>
<td><p>N.A.</p></td>
<td><p>N.A.</p></td>
<td><p>This record is 1 (“Connected”) if all PVs have connected in the USBCTR_SNL State
Notation Language program.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)EraseAll</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_ERASE</p></td>
<td><p>Erases the MCS data, setting the arrays and the elapsed times to 0.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)EraseStart</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_ERASE</p></td>
<td><p>Erases the MCS data and then starts MCS acquisition by forward linking to StartAll.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)StartAll</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_START_ACQUIRE</p></td>
<td><p>Starts MCS acquisition.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)Acquiring</p></td>
<td><p>busy</p></td>
<td><p>N.A.</p></td>
<td><p>N.A.</p></td>
<td><p>Busy record is 1 (“Acquiring”) when MCS is acquiring and 0 (“Done”) when done..</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)StopAll</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_STOP_ACQUIRE</p></td>
<td><p>Stops MCS acquisition.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)PresetReal</p></td>
<td><p>ao</p></td>
<td><p>asynFloat64</p></td>
<td><p>MCA_PRESET_REAL</p></td>
<td><p>Preset real time. If non-zero acquisition will stop after this time.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)ElapsedReal</p></td>
<td><p>ai</p></td>
<td><p>asynFloat64</p></td>
<td><p>MCA_ELAPSED_REAL</p></td>
<td><p>Elapsed real time.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)ReadAll</p></td>
<td><p>bo</p></td>
<td><p>N.A</p></td>
<td><p>N.A.</p></td>
<td><p>Forces a read of all of the array data. This is done by the SNL program.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)NuseAll</p></td>
<td><p>longout</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_NUM_CHANNELS</p></td>
<td><p>The number of time points to acquire.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)CurrentChannel</p></td>
<td><p>longin</p></td>
<td><p>asynInt32</p></td>
<td><p>MCS_CURRENT_POINT</p></td>
<td><p>The current time point in the acquisition.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Dwell</p></td>
<td><p>ao</p></td>
<td><p>asynFloat64</p></td>
<td><p>MCA_DWELL_TIME</p></td>
<td><p>The dwell time per time point in internal channel advance mode.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)ChannelAdvance</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_CH_ADV_SOURCE</p></td>
<td><p>The channel advance source. 0=”Internal” uses Dwell record, 1=”External” uses External
Clock Input on USB-CTR module.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Prescale</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCA_PRESCALE</p></td>
<td><p>The prescale factor for the external channel advance source. To use Prescale the
external clock must be input to the counter channel selected by PrescaleCounter,
and the output of the PrescaleCounter counter channel must be connected to the External
Clock Input. Note that due to hardware limitations Prescale must be &amp;gt; 1. For
no prescaling the external channel advance source must be connected directly to
the External Clock Input.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R))MCSCounterNEnable (N=1-8)</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>N.A.</p></td>
<td><p>Enable counter N in MCS mode. Choices are “No” (0) and “Yes” (1).</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R))MCSDIOEnable</p></td>
<td><p>bo</p></td>
<td><p>asynInt32</p></td>
<td><p>N.A.</p></td>
<td><p>Enable collecting digital I/O word in MCS mode. Choices are “No” (0) and “Yes” (1).</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)PrescaleCounter</p></td>
<td><p>mbbo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCS_PRESCALE_COUNTER</p></td>
<td><p>The counter channel to use for prescaling the external channel advance in MCS mode.
0=”CNTR0” … 7=”CNTR7”.</p></td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)Point0Action</p></td>
<td><p>mbbo</p></td>
<td><p>asynInt32</p></td>
<td><p>MCS_POINT0_ACTION</p></td>
<td><p>Controls how the first time point in the MCS scan is handled. The USB-CTR always
reads the current scaler counts as soon as MCS acquisition begins, rather than after
the first channel advance occurs. This record selects one of the following 3 modes:</p>
<ul class="simple">
<li><p>“Clear” (0) In this mode the scalers are cleared to 0 before they are read. This
means that the counts in first time point for each counter will be 0.</p></li>
<li><p>“No clear” (1) In this mode the scalers are not cleared before they are read.
This means that there will normally be a large number of counts in the first time
point, since the counters will have been counting since they were last cleared.</p></li>
<li><p>“Skip” (2) In this mode the first time point will be skipped, i.e. not read into
the mca or waveform records. The first time point will thus contain the counts after
MCS acquisition was started until the first channel advance signal is received,
either internal or external. This is probably the mode that will be most useful.
However, it does require N+1 channel advance signals rather than N. This is handled
by the driver for internal channel advance. But for external channel advance the
user must ensure that N+1 pulses are sent. For example if NUseAll=2000 then 2001
pulses must be sent before acquisition will stop.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)TrigMode</p></td>
<td><p>mbbo</p></td>
<td><p>asynInt32</p></td>
<td><p>TRIGGER_MODE</p></td>
<td><p>Controls trigger of the MCS scan. Choices are:</p>
<ul class="simple">
<li><p>“Rising edge” (0)</p></li>
<li><p>“Falling edge” (1)</p></li>
<li><p>“High level” (2)</p></li>
<li><p>“Low level” (3)</p></li>
</ul>
<p>The trigger can be used to trigger MCS acquisition from an external trigger signal.
The MCS must be first started with the StartAll record. Acquisition will start when
the specfied trigger condition is met. The MCS acquisition is always done in triggered
mode. If triggered acquisition is not desired then simply do not connect any signal
to the Trigger Input and set Mode=”Low”. This will cause the trigger condition to
always be satisfied.</p>
<p>There is actually a serious problem with using external triggers in MCS mode.
See the note below.</p>
</td>
</tr>
<tr class="row-odd"><td><p>$(P)$(R)MaxChannels</p></td>
<td><p>longin</p></td>
<td><p>asynInt32</p></td>
<td><p>MCS_MAX_POINTS</p></td>
<td><p>The maximum number of points in MCS arrays. This is determined by the value of the
MAX_POINTS macro parameter when loading the MCA or waveform records.</p></td>
</tr>
<tr class="row-even"><td><p>$(P)$(R)Model</p></td>
<td><p>mbbi</p></td>
<td><p>asynInt32</p></td>
<td><p>MODEL</p></td>
<td><p>The model number of the counter module. 0=”USB-CRT08”, 1=”USB-CTR04”.</p></td>
</tr>
</tbody>
</table>
<section id="notes-on-external-channel-advance">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Notes on external channel advance</a><a class="headerlink" href="#notes-on-external-channel-advance" title="Link to this heading"></a></h3>
<p>There are 2 problem with external channel advance that can cause the number channels collected
(final value of CurrentChannel) to be less than that requested (NuseAll).</p>
<p>The first problem only happens when all of the following 4 conditions are met:</p>
<ol class="arabic simple">
<li><p>ChannelAdvance = External</p></li>
<li><p>TrigMode = Anything that would prevent counting from starting immediately, e.g. Rising edge, Falling edge,
Low level (when the trigger input is currently high), or High level (when the trigger input is currently low).</p></li>
<li><p>Pulses are arriving on CLKI before the trigger condition is satisfied.</p></li>
<li><p>The requested number of CLKI pulses (NuseAll) have not yet arrived when the trigger condition is satisfied.</p></li>
</ol>
<p>The problem is clearly that the USBCTR should be ignoring any CLKI pulses that arrive before the trigger condition is met,
but it does not.</p>
<p>Consider the following conditions:</p>
<ul class="simple">
<li><p>CLKI input is 100 Hz, and is arriving continuously</p></li>
<li><p>NuseAll = 2048</p></li>
<li><p>The total time to collect the data should be 20.48 seconds.</p></li>
<li><p>The EraseStart is processed at time 0, starting the MCS</p></li>
<li><p>If the trigger condition is satisfied at time=5.12 seconds, then it will only acquire 1526 channels.
This is because it did not ignore the first 512 CLKI signals that arrived before the trigger condition was satisfied.</p></li>
</ul>
<p>I believe this is a bug in the USBCTR firmware. I should report it to them,
but I am not sure they will see it as a high enough priority to fix it.
They will want to have a C test program to demonstrate the problem, which would be some work.</p>
<p>The second problem happens when the following 3 conditions are met:</p>
<ol class="arabic simple">
<li><p>ChannelAdvance = External</p></li>
<li><p>The number of external channel advance pulses received on CLKI is less than the requested number (NuseAll).</p></li>
<li><p>The dwell time (Dwell) is set to less than 0.01 second.</p></li>
</ol>
<p>For example:</p>
<ul class="simple">
<li><p>External channel advance pulse rate into CLKI is 1000 Hz.</p></li>
<li><p>Dwell = 0.001</p></li>
<li><p>NuseAll = 2048</p></li>
<li><p>The actual number of pulses sent to CLKI is 2047</p></li>
</ul>
<p>One would expect that the final value of CurrentChannel would be 2047.
The MCS would not automatically stop, because it is expecting one more external channel advance.
What is actually observed is that the final value of CurrentChannel is 2033, not 2047.</p>
<p>This is the explanation for this:</p>
<ul class="simple">
<li><p>The USB-CTR08 can transfer the MCS data to the EPICS driver in 2 modes:</p>
<ul>
<li><p>SINGLEIO mode. In this mode the counts for each dwell period are immediately sent by USB to the EPICS computer.</p></li>
<li><p>BLOCKIO mode. In this mode the USBCTR buffers the data and sends it in blocks to the EPICS computer.</p></li>
</ul>
</li>
<li><p>SINGLEIO mode is desired at long dwell times, so that the user can see the MCS array data
without any delay from waiting for the buffer on the USB-CTR08 to fill up.</p></li>
<li><p>BLOCKIO is needed at very short dwell times because the USB bus cannot keep up with too many short transactions per second.</p></li>
<li><p>The USB-CTR08 always pushes MCS data to the host computer. It does not support pulling the data via a request from the host.</p></li>
<li><p>The EPICS driver transitions from SINGLEIO to BLOCKIO when Dwell is less than 0.01 seconds.</p></li>
</ul>
<p>In general I recommend that Dwell be set approximately the period of the external channel advance pulses.
This will ensure the correct 32/16 bit switch as explained above.</p>
<p>In the example above with Dwell=0.001 it was thus using BLOCKIO.
The problem arises because the USB-CTR08 was told to collect 2048 dwell periods, but only receives 2047 external CLKI pulses.
It thus has a partially full buffer that it will push to the host when pulse 2048 is received.
But because that final pulse is never received the final buffer is never sent, and CurrentChannel only gets to 2033.</p>
<p>This problem can be worked around by always setting Dwell to 0.01, forcing it to use SINGLEIO
even for external pulse periods shorter than 0.01 seconds (100 Hz).
Surprisingly I have found that SINGLEIO works reliably for dwell times as short as 10 microseconds, i.e. 100 kHz.
This is true no matter how many counter channels are enabled, i.e. have CounterNEnable=1.
However, above 100 kHz channel advance frequency SINGLEIO does not work, and one needs to decrease Dwell to switch to BLOCKIO.</p>
<p>Note that this problem only occurs when the number of advance pulses received is less than NuseALL.
If the number of pulses is at least NuseAll then CurrentChannel will always reach NuseAll.
This is true whether it is running with SINGLEIO or BLOCKIO.</p>
</section>
</section>
<section id="using-an-external-gate-signal">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Using an external gate signal</a><a class="headerlink" href="#using-an-external-gate-signal" title="Link to this heading"></a></h2>
<p>It is possible to use an external gate signal to inhibit counting in both scaler mode and MCS mode.
However, this requires the installation of one external TTL chip containing an OR gate.
This is needed because in scaler mode counters 1-7 need to be gated by either counter 0 out
(C0O) or by the external gate.  There is no way to do this without an external chip.
To use an external gate the following wiring is required.</p>
<ul class="simple">
<li><p>Install an external chip with at least one OR gate (e.g. 74HC32N or equivalent).</p></li>
<li><p>Connect +5V from the USB-CTR08 to the +5V on the chip.</p></li>
<li><p>Connect ground from the USB-CTR08 to the ground on the chip.</p></li>
<li><p>Connect the external gate signal to the first input of the OR gate.</p></li>
<li><p>Connect channel 0 output (C0O) to the second input of the OR gate.</p></li>
<li><p>Connect the output of the OR gate to all counter gate inputs (C0GT-C7GT).</p></li>
</ul>
<p>With these changes the external gate will inhibit counting in scaler mode.
In MCS mode the external gate will inhibit counting but will not inhibit channel advance.</p>
</section>
<section id="packaging">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Packaging</a><a class="headerlink" href="#packaging" title="Link to this heading"></a></h2>
<p>The photo below shows the USB-CTR08 mounted in a box with BNC connectors on the front
and back for inputs and outputs.  It also shows the 74HC32N chip mounted on top to
implement the external gate as explained above.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="_images/USB-CTR08_box.jpg"><img alt="_images/USB-CTR08_box.jpg" src="_images/USB-CTR08_box.jpg" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-text"><strong>USB-CTR08 box showing 74HC32N for external gate</strong></span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The photo below shows a box with the USB-CTR08 on the left, the USB-3114 in the middle,
and the USB-1808X on the right.  This box contains most of the analog input, analog output,
digital I/O, and counter/timer functions required to run an experimental station at the APS.</p>
<figure class="align-center" id="id7">
<img alt="_images/3ModuleBox.jpg" src="_images/3ModuleBox.jpg" />
<figcaption>
<p><span class="caption-text"><strong>Box with the USB-CTR08, USB-3114, and USB-1808X</strong></span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="medm-screens">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">medm screens</a><a class="headerlink" href="#medm-screens" title="Link to this heading"></a></h2>
<p>The following is the main medm screen for controlling the USB-CTR04/08.</p>
<figure class="align-center" id="id8">
<img alt="_images/USBCTR.png" src="_images/USBCTR.png" />
<figcaption>
<p><span class="caption-text"><strong>USBCTR.adl</strong></span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The following is the medm screen for the EPICS scaler record using the
USB-CTR04/08.</p>
<figure class="align-center" id="id9">
<img alt="_images/USBCTR_scaler.png" src="_images/USBCTR_scaler.png" />
<figcaption>
<p><span class="caption-text"><strong>scaler_full.adl</strong></span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The following is the medm screen for controlling the MCS mode of the
USB-CTR04/08.</p>
<figure class="align-center" id="id10">
<img alt="_images/USBCTR_MCS.png" src="_images/USBCTR_MCS.png" />
<figcaption>
<p><span class="caption-text"><strong>USBCTR_MCS.adl</strong></span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id11">
<img alt="_images/USBCTR_MCS_plots.png" src="_images/USBCTR_MCS_plots.png" />
<figcaption>
<p><span class="caption-text"><strong>USBCTR_MCS_plots.adl</strong></span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="performance-measurements">
<span id="performance-ctr"></span><h2><a class="toc-backref" href="#id24" role="doc-backlink">Performance measurements</a><a class="headerlink" href="#performance-measurements" title="Link to this heading"></a></h2>
<p>The binary input bits are polled at 100 Hz, and the input records have
SCAN=I/O Intr. There is thus a worse-case latency of 0.01 seconds in
detecting a transition on these bits.</p>
<p>If the scaler record is run under the following conditions:</p>
<ul class="simple">
<li><p>Counter 0 Output connected to the Gate Input of Counters 1-7</p></li>
<li><p>Pulse generator 0 frequency=32 MHz, connected to Counter 0 input</p></li>
<li><p>Pulse generator 1 frequency=32 MHz, connected to Counter 1 input</p></li>
<li><p>Pulse generator 2 frequency=32 MHz, connected to Counter 2 input</p></li>
<li><p>Pulse generator 3 frequency=32 MHz, connected to Counter 3 input</p></li>
<li><p>Scaler record .FREQ field = 3.2e7</p></li>
<li><p>Scaler record preset time = 1.0 second</p></li>
<li><p>Only scaler channel 1 is preset (.G1=Y, .G2-.G8=N)</p></li>
</ul>
<p>After each count cycle .S1=32000000 counts exactly, .S2-.S4=32000000 +=
1 count. There is thus no cross-talk with all channels running at 32
MHz, and the gate signals are working as designed.</p>
<p>If Pulse Generator 2 is changed to 3.2 MHz, .PR2 is set to 1600000, and
.G2 is set to Y, then the scaler is stopped by channel 2 in the software
polling routine. In this case it counts for exactly 0.50 seconds.
However, if .PR2 is increased to 1600001 then it counts for 0.51
seconds. This corresponds to the worst case error due to the 100 Hz rate
at which the scaler values are read. Note that all counters are active
for exactly 0.51 seconds, so the counts all accurately reflect this
count time. The count time is just slightly longer than requested due to
the finite polling interval.</p>
<p>In MCS mode the measured minimum dwell time in both internal and
external channel advance mode agrees with the datasheet, i.e. 250 ns *
number of active counters. I was not able to measure any dead time
between time bins in MCS mode. When sending exactly 8000000 pulses at 8
MHz to channel 0 with a 1 ms internal dwell time the total number of
counts in the MCA record was 8000000. This means that no pulses were
lost during the 1000 channel advances that happened during this time.</p>
</section>
<section id="restrictions">
<span id="id4"></span><h2><a class="toc-backref" href="#id25" role="doc-backlink">Restrictions</a><a class="headerlink" href="#restrictions" title="Link to this heading"></a></h2>
<ul>
<li><p>The EPICS driver only uses the Totalize mode of the counters. With
the scaler record it does a one-shot totalize, while in the MCS mode
it totalizes into time-bins. The USB-CTR08 is also capable of running
in 3 other modes.</p>
<ol class="arabic simple">
<li><p>In Period mode it measures the time between the rising or falling
edges of successive input pulses.</p></li>
<li><p>In Pulse Width measurement mode it measures the time between the
rising and falling edges of a each pulse.</p></li>
<li><p>In Timing Mode it measures the time between an event on the
counter input and another event on the counter gate.</p></li>
</ol>
<p>None of these modes are currently supported by the EPICS driver, but
they could be added in a future release.</p>
</li>
<li><p>In Totalize mode each counter has many options in how it works: count
up/down, gate clears counter, gate controls counter direction, preset
counts where the output signal goes high/low, polarity of the output,
etc. These options are not currently exposed in the EPICS driver.</p></li>
<li><p>The EPICS driver only works in 32-bit counter depth mode. The
USB-CTR08 can count with a 64-bit counter depth. asyn does not
currently have support for 64-bit integer data types, so this cannot
be supported.</p></li>
<li><p>To work with the scaler record the counter 0 output must be wired to
the gate inputs of counters 1-7 as discussed above.</p></li>
</ul>
<hr class="docutils" />
<div class="line-block">
<div class="line">Suggestions and Comments to:</div>
<div class="line"><a class="reference external" href="mailto:rivers&#37;&#52;&#48;cars&#46;uchicago&#46;edu">Mark Rivers</a> :
(<a class="reference external" href="mailto:rivers&#37;&#52;&#48;cars&#46;uchicago&#46;edu">rivers<span>&#64;</span>cars<span>&#46;</span>uchicago<span>&#46;</span>edu</a>)</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="measCompMultiFunctionDoc.html" class="btn btn-neutral float-left" title="Driver for Multi-Function Devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Mark Rivers.
      <span class="lastupdated">Last updated on 2025-May-19.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>